import React, { useState, useEffect } from 'react';
import { useParams, useNavigate } from 'react-router-dom';
import apiClient from '../api/axiosConfig';

function FormViewer() {
    const { formId } = useParams(); // Get form ID from URL parameter
    const navigate = useNavigate();
    const [form, setForm] = useState(null); // State to hold the fetched form structure
    const [answers, setAnswers] = useState({}); // State to hold user's answers { questionId: value }
    const [isLoading, setIsLoading] = useState(true);
    const [error, setError] = useState(null);
    const [isSubmitting, setIsSubmitting] = useState(false); // State for submission loading
    const [submitError, setSubmitError] = useState(null); // State for submission error

    // Fetch form structure on component mount
    useEffect(() => {
        const fetchForm = async () => {
            setIsLoading(true);
            setError(null);
            try {
                const response = await apiClient.get(`/forms/${formId}`);
                setForm(response.data);
                // Initialize answers state based on fetched questions
                const initialAnswers = {};
                response.data.questions.forEach(q => {
                    // Use question._id which is automatically generated by mongoose for subdocuments
                    initialAnswers[q._id] = ''; // Default empty answer
                });
                setAnswers(initialAnswers);
            } catch (err) {
                console.error('Error fetching form:', err);
                setError(err.response?.data?.message || `Failed to load form with ID ${formId}. It might not exist.`);
                setForm(null); // Ensure form is null on error
            } finally {
                setIsLoading(false);
            }
        };

        fetchForm();
    }, [formId]); // Re-fetch if formId changes

    // Handle changes in input fields
    const handleAnswerChange = (questionId, value) => {
        setAnswers(prevAnswers => ({
            ...prevAnswers,
            [questionId]: value,
        }));
    };

    // Handle form submission (logic to be added in the next step)
    const handleSubmit = async (event) => {
        event.preventDefault();
        setIsSubmitting(true);
        setSubmitError(null);
        console.log('Submitting answers:', answers); // Placeholder

        // --- Submission logic will go here in the next step ---
        // Example structure:
        // try {
        //   const payload = { formId, answers: Object.entries(answers).map(([questionId, value]) => ({ questionId, value })) };
        //   await apiClient.post(`/forms/${formId}/responses`, payload); // Or POST /api/responses
        //   alert('Response submitted successfully!');
        //   navigate('/'); // Redirect after successful submission
        // } catch (err) {
        //   console.error('Error submitting response:', err);
        //   setSubmitError(err.response?.data?.message || 'Failed to submit response.');
        // } finally {
        //   setIsSubmitting(false);
        // }
        // For now, just simulate delay and stop loading
        setTimeout(() => {
             alert("Submission logic not yet implemented in this step.");
             setIsSubmitting(false);
        }, 500);
    };

    // --- Rendering Logic ---
    if (isLoading) {
        return <div>Loading form...</div>;
    }

    if (error) {
        return <div style={{ color: 'red' }}>Error: {error}</div>;
    }

    if (!form) {
        // This case might be redundant if error is always set, but good practice
        return <div>Form not found or could not be loaded.</div>;
    }

    return (
        <div>
            <h2>{form.title}</h2>
            {form.description && <p>{form.description}</p>}
            <hr />

            <form onSubmit={handleSubmit}>
                {form.questions.map((question, index) => (
                    <div key={question._id || index} style={{ marginBottom: '20px' }}> {/* Use question._id as key */}
                        <label htmlFor={`q-${question._id}`}>
                            <strong>{index + 1}. {question.label}</strong>
                            {/* Add indicator for required questions if that field is added later */}
                        </label>
                        {question.type === 'text' && (
                            <input
                                type="text"
                                id={`q-${question._id}`}
                                value={answers[question._id] || ''}
                                onChange={(e) => handleAnswerChange(question._id, e.target.value)}
                                // required={question.required} // Add later if needed
                                style={{ width: '100%', marginTop: '5px' }}
                            />
                        )}
                        {question.type === 'multiple_choice' && (
                            <div style={{ marginTop: '5px' }}>
                                {question.options.map((option, oIndex) => (
                                    <div key={oIndex}>
                                        <input
                                            type="radio"
                                            id={`q-${question._id}-opt-${oIndex}`}
                                            name={`q-${question._id}`} // Group radio buttons by question ID
                                            value={option}
                                            checked={answers[question._id] === option}
                                            onChange={(e) => handleAnswerChange(question._id, e.target.value)}
                                            // required={question.required} // Add later if needed
                                        />
                                        <label htmlFor={`q-${question._id}-opt-${oIndex}`} style={{ marginLeft: '5px' }}>
                                            {option}
                                        </label>
                                    </div>
                                ))}
                            </div>
                        )}
                        {/* Add rendering for other question types here */}
                    </div>
                ))}

                {submitError && <p style={{ color: 'red' }}>Submission Error: {submitError}</p>}

                <button type="submit" disabled={isSubmitting || isLoading}>
                    {isSubmitting ? 'Submitting...' : 'Submit Response'}
                </button>
            </form>
        </div>
    );
}

export default FormViewer;
